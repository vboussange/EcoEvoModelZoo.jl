var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EcoEvoModelZoo","category":"page"},{"location":"#EcoEvoModelZoo","page":"Home","title":"EcoEvoModelZoo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DocStringExtensions.README","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EcoEvoModelZoo]\nPrivate = false\n<!-- Filter = t -> typeof(t) <: AbstractModel -->","category":"page"},{"location":"#EcoEvoModelZoo.AkessonModel","page":"Home","title":"EcoEvoModelZoo.AkessonModel","text":"This model is inspired from Akesson et al. 2021.\n\nSpecialized variants are provided in other AbstractModels. Best constructure with init_akesson_model.\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.EcoEvoGraph","page":"Home","title":"EcoEvoModelZoo.EcoEvoGraph","text":"This model is inspired from Boussange & Pellissier. 2022\n\nArguments\n\nmp: the model parameters\ng: the spatial graph\nphen_space: the discretized phenotypic space\nbirth_fn: the birth function. Should be of the form birth_fn(x, s, p)\ncompetition_fn: the competition function. Should be of the form competition_fn(u_xs2, x, s1, s2, p)\n\nMathematical model\n\n∂ₜuˣ(s) = uˣ(s)[birth_fn(x, s, p) - uˣ(s)∫competition_fn(uˣ(s₂), x, s, s₂, p) ds₂] + 1/2 μ σ² Δₛuˣ(s) + m L u(s)\n\nwhere L is the Laplacian matrix of the spatial graph g.\n\nExample 1\n\nusing ParametricModels\nusing UnPack\nusing DocStringExtensions\nusing Statistics\nusing ComponentArrays\nusing Distributions\nusing OrdinaryDiffEq\nusing UnPack\n## Defining phenotypic space and spatial graph\nM = 7\ng = star_graph(M)\n\nrS = 1f0\ndS = 0.02f0\nphen_space = collect(range(-rS,rS,step=dS)) #grid\n\n##\n# Defining birth and competition functions\nsoptim = 0.5f0 * [-1,1,-1,1,-1,1,-1]\nbirth_fn(x, s, p) = max(0f0, 1f0 - (soptim[x] - s)^2)\ncompetition_fn(u_xs2, x, s1, s2, p) = u_xs2 ./ p.K\n\n## Defining parameters\nσ_mu = 5f-2;\nmu = 0.1f0\nm = 0.1\nK = 1.\n\np = ComponentArray(σ_mu = σ_mu,\n                    mu = mu,\n                    m = m,\n                    K = K)\n\n\n## rest of the simulation\ntend = 1000f0\ntspan = (0f0,tend)\ntsteps = (tspan[1]):1.:(tspan[end])\nu0 = vcat([K .* pdf.(Normal(so,σ_mu),phen_space') for so in soptim]...)\n\nmp = ModelParams(;p,\n                tspan,\n                u0,\n                alg=Tsit5(),\n                saveat = tsteps)\n\nmodel = EcoEvoGraph(mp, g, phen_space, birth_fn, competition_fn)\n\n@time sol = simulate(model)\n\n# Plotting results!\nusing PythonCall; plt = pyimport(\"matplotlib.pyplot\")\nfig, ax = plt.subplots(1)\nax.plot(model.phen_space, sol[end][1,:], color = \"tab:red\", label = \"Node 1\")\nax.plot(model.phen_space, sol[end][2,:], color = \"tab:blue\", label = \"Node 2\")\nax.set_xlabel(\"Phenotype\")\nax.set_ylabel(\"Population number\")\ndisplay(fig)\n\nExample 2: trait dependent competition\n\n# Trait dependent compeition\nrS = 3f0\ndS = 0.02f0\nphen_space = collect(range(-rS,rS,step=dS)) #grid\n\np = ComponentArray(σ_mu = σ_mu,\n                    mu = mu,\n                    m = m,\n                    K = K,\n                    σ_α = 0.5)\n# trait dependent competition\ncompetition_fn(u_xs2, x, s1, s2, p) = u_xs2 * exp(- 0.5f0 * (s1 - s2)^2 ./ p.σ_α^2) ./ p.K\n\nu0 = vcat([K .* pdf.(Normal(so,σ_mu),phen_space') for so in soptim]...)\n\nmp = ModelParams(;p,\n                tspan,\n                u0,\n                alg=Tsit5(),\n                saveat = tsteps)\nmodel = EcoEvoGraph(mp, g, phen_space, birth_fn, competition_fn)\n\nsol = simulate(model)\nfig, ax = plt.subplots(1)\nax.set_title(\"Trait-dependent competition\")\nax.plot(model.phen_space, sol[end][1,:], color = \"tab:red\", label = \"Node 1\")\nax.plot(model.phen_space, sol[end][2,:], color = \"tab:blue\", label = \"Node 2\")\nax.set_xlabel(\"Phenotype\")\nax.set_ylabel(\"Population number\")\ndisplay(fig)\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.EcosystemModelMcCann","page":"Home","title":"EcoEvoModelZoo.EcosystemModelMcCann","text":"EcosystemModelMcKann\n\nThis model is inspired from McCann 1994.  Similar to EcosystemModelOmnivory, but without monivory.\n\nModel parameters\n\nx_c, x_p: mass-specific metabolic rate of consumers and predators\ny_c, y_p: ingestion rate per unit metabolic rate of consumers and predators.\nR_0, C_0: half saturation densities for the type II functional responses of the consumers and predators\n\nExample\n\n```julia alg = BS3() abstol = 1e-6 reltol = 1e-6 tspan = (0., 800) tsteps = 550:4:800 ptrue = (xc = [0.4],          xp = [0.08],          yc = [2.01],         yp = [5.00],          R0 = [0.16129],          C_0 = [0.5])\n\nu0_true = [0.5,0.8,0.5]\n\nmodel = EcosystemModelMcCann(ModelParams(;p = ptrue,                                         tspan,                                         u0 = u0true,                                         alg,                                         reltol,                                         abstol,                                         saveat = tsteps,                                         verbose = false, # suppresses warnings for maxiters                                         maxiters = 50000,                                         )) sol = simulate(model, u0 = u0true)\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.EcosystemModelOmnivory","page":"Home","title":"EcoEvoModelZoo.EcosystemModelOmnivory","text":"EcosystemModelOmnivory\n\nThis model is inspired from McCann 1997.\n\nModel parameters\n\nx_c, x_p: mass-specific metabolic rate of consumers and predators\ny_c, y_pr, y_pc: ingestion rate per unit metabolic rate of consumers and predators.\nR_0, R_02, C_0 half saturation densities for the type II functional responses of the consumers and predators\nω: omnivory strength\n\nExample\n\nalg = BS3()\nabstol = 1e-6\nreltol = 1e-6\ntspan = (0., 800)\ntsteps = 550:4:800\n\np_true = (x_c = [0.4], \n        x_p = [0.08], \n        y_c = [2.01], \n        y_pr = [2.00], \n        y_pc = [5.0], \n        R_0 = [0.16129], \n        R_02 = [ 0.5], \n        C_0 = [0.5],\n        ω =[ 0.4])\n\nu0_true = [0.5,0.8,0.5]\n\n\nmodel = EcosystemModelOmnivory(ModelParams(;p = p_true,\n                                        tspan,\n                                        u0 = u0_true,\n                                        alg,\n                                        reltol,\n                                        abstol,\n                                        saveat = tsteps,\n                                        verbose = false, # suppresses warnings for maxiters\n                                        maxiters = 50_000,\n                                        ))\nsol = simulate(model, u0 = u0_true)\n\n```\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.Landscape","page":"Home","title":"EcoEvoModelZoo.Landscape","text":"Returns landscape parameters\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.ResourceCompetition","page":"Home","title":"EcoEvoModelZoo.ResourceCompetition","text":"The ResourceCompetition model is a type of ecological model that simulates competition for resources between different species of plankton. This model is inspired by Huisman et al. 1999 Nature.\n\nArguments\n\nmp is a ModelParams object that contains information about the time span, the algorithm to use for numerical integration, and the tolerances to use.\nnN is the number of plankton species.\nnR is the number of resources.\nS is a vector of length nR containing the supply rates of each resource.\nmu: function for the ResourceCompetition model is set to the default function:\n\nμ(R, r, K) = r .* R ./ (K .+ R)\n\nwhere:\n\nR is a vector of length nR containing the current concentration of each resource.\nr is a vector of length nN containing the maximum uptake rate of each plankton species.\nK is a vector of length nN containing the half-saturation constant of each plankton species.\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.ResourceCompetitionSmoothMin","page":"Home","title":"EcoEvoModelZoo.ResourceCompetitionSmoothMin","text":"This model is inspired from Huisman et al. 1999 Nature., but where Leibig's law is replaced by imperfect substituable resources (smooth minimum). The smooth min function is parametrized by s, which is a trainable parameter.\n\nArguments\n\nmp::MP: ModelParams struct containing parameter values for the model.\nnN::NN: Number of plankton species in the model.\nnR::NR: Number of resource species in the model.\nS::SS: Supply rates.\n\nExample\n\nalg = BS3()\nabstol = 1e-6\nreltol = 1e-6\ntspan = (0.,1000.)\nstep = 2.\nnN = 5\nnR = 5\nr = ones(nN)\nm = D = 0.25\nS = [6., 10., 14., 4, 9]\nK = [0.39 0.34 0.30 0.24 0.23;\n    0.22 0.39 0.34 0.30 0.27;\n    0.27 0.22 0.39 0.34 0.30;\n    0.30 0.24 0.22 0.39 0.34;\n    0.34 0.30 0.22 0.20 0.39]'\n\nC = [0.04 0.04 0.07 0.04 0.04;\n    0.08 0.08 0.08 0.10 0.08;\n    0.10 0.10 0.10 0.10 0.14;\n    0.05 0.03 0.03 0.03 0.03;\n    0.07 0.09 0.07 0.07 0.07]'\ns = -7.\n\np_true = (r = r, m = [m], D = [D], K = K, C = C, s = Float64[s])\n\nN0 = [0.1 + i / 100 for i in 1:5]\nR0 = S\nu0 = [N0;R0]\ntsteps = tspan[1]:step:tspan[2]\n\nmodel = ResourceCompetitionSmoothMin(ModelParams(;p = p_true,\n                                        tspan,\n                                        u0,\n                                        alg,\n                                        reltol,\n                                        abstol,\n                                        saveat = tsteps\n                                        ), \n                                        nN, nR, S)\n\n# Species 1:5\nsol = simulate(model, u0 = u0)\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.SimpleEcosystemModel","page":"Home","title":"EcoEvoModelZoo.SimpleEcosystemModel","text":"General multitrophic ecosystem model that models the population dynamics of multiple species in an ecosystem.\n\nArguments\n\nmp: Model parameters of type ModelParams.\nintinsic_growth_rate: A function that takes in the model parameters p and time t and returns the intrinsic growth rate of the population.\ncarrying_capacity: A function that takes in the model parameters p and time t and returns the carrying capacity of the population.\ncompetition: A function that takes in the state u, model parameters p, and time t and returns the effect of population density on the growth rate.\nresource_conversion_efficiency: A function that takes in the model parameters p and time t and returns the efficiency of converting resources into population growth.\nfeeding: A function that takes in the state u, model parameters p, and time t and returns the feeding rates of the population.\n\nExample 1\n\nSimulating a chaotic 5 compartment food web model proposed in Post et al. 2000.\n\nalg = BS3()\nabstol = 1e-6\nreltol = 1e-6\ntspan = (0., 600)\ntsteps = (tspan[1]):1.:(tspan[end])\nN = 5 # number of compartment\n\nx_c = 0.15, \nx_p = 0.08\ny_c = 2.3\ny_p = 1.7\nR_0 = 0.25\nC_0 = 0.5\nω = 0.2\n\n# constructing simple chain foodweb\n# Population vector is organised in such a way\n# N = [R1, C1, P, R2, C2]\nfoodweb = SimpleWeightedDiGraph(N)\nadd_edge!(foodweb, 2, 1, 1.) # C1 to R1\nadd_edge!(foodweb, 5, 4, 1.) # C2 to R2\nadd_edge!(foodweb, 3, 2, ω) # P to C1\nadd_edge!(foodweb, 3, 5, 1-ω) # P to C2\n\nH = sparse(zeros(N,N))\nH[2,1] = 1 / (x_c * y_c); H[5,4] = 1 / (x_c * y_c); \nH[3,2] = 1 / (x_p * y_p); H[3,5] = 1 / (x_p * y_p)\n\nq = sparse(zeros(N,N))\nq[2,1] = x_c * y_c / R_0; q[5,4] = x_c * y_c / R_0;\nq[3,2] = x_p * y_p / C_0; q[3,5] = x_p * y_p / C_0\n\np = (r = vcat(1., -x_c, -x_p, 1., -x_c,), \n        K = ones(N), \n        A = diagm(vcat(1,0,0,1,0)), \n        ϵ = ones(N), \n        q = q,\n        H = H, \n        W = adjacency_matrix(foodweb))\n\nu0_true = rand(N)\n\n\nmodel = SimpleEcosystemModel(;mp = ModelParams(;p,\n                                        tspan,\n                                        u0 = u0_true,\n                                        alg,\n                                        reltol,\n                                        abstol,\n                                        saveat = tsteps,\n                                        verbose = false, # suppresses warnings for maxiters\n                                        maxiters = 50_000,\n                                        ))\nsol = simulate(model)\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.Temperature","page":"Home","title":"EcoEvoModelZoo.Temperature","text":"Temperature as a function of space (x), time (t), and some climate parameters\n\n\n\n\n\n","category":"type"},{"location":"#EcoEvoModelZoo.funcresp!-Tuple{Any, Any, Any, Trophic{true}}","page":"Home","title":"EcoEvoModelZoo.funcresp!","text":"funcresp!(F, n, p, _)\n\n\nType II functional response Input:\n\nn: Vector of population densities of all species in a given patch\nTh: Vector of handling times (with dummy values for resource species)\narate: Vector of attack rates (with dummy values for resource species)\nW: Adjacency matrix of trophic network; W(i,j)=1 if i eats j and 0 otherwise\n\nOutput:\n\nA matrix F(i,j), the feeding rate of consumer i on resource j\n\n\n\n\n\n","category":"method"},{"location":"#EcoEvoModelZoo.generate_network-Tuple{Int64, Int64}","page":"Home","title":"EcoEvoModelZoo.generate_network","text":"generate_network(SR::Int, SC::Int)\n\nreturn matrix W[i,j], which is nonzero if consumer i eats resource j SR is the number of resource, SC the number of consumer species.\n\nThe bipartite network is generated as follows.  First, both resources and consumers are labeled consecutively,  based on their initial temperature adaptations:  resource 1 / consumer 1 are the most cold-adapted,  and resource S / consumer S the most warm-adapted.  Next, we always put a feeding link between consumer i and resource i.  Finally, each consumer is randomly linked to four other resource species.  This yields a feeding network where every consumer is  connected to five resources altogether.\n\nNote: it seems that the definition of W_ij is that it determines which resource i is eat by consumer j\n\n\n\n\n\n","category":"method"},{"location":"#EcoEvoModelZoo.init_akesson_model-Union{Tuple{}, Tuple{Tr}} where Tr","page":"Home","title":"EcoEvoModelZoo.init_akesson_model","text":"init_akesson_model(\n;\n    mp,\n    land,\n    temp,\n    width_growth,\n    competition,\n    trophic,\n    SR,\n    SC,\n    kwargs...\n)\n\n\nArguments\n\nwidth_growth::WidthGrowth: an instance of the WidthGrowth struct representing the width growth function.\ncompetition::Competition: an instance of the Competition struct representing the competition function.\ntrophic::Tr: an instance of the Trophic struct representing the trophic interaction. Defaults to Trophic{false}() representing a single trophic level.\nSR::Int: the number of species in each patch. Defaults to 50.\nSC::Int: the number of patches. Defaults to 0 (only one patch).\nkwargs: additional keyword arguments to pass to the Base.ODEProblem constructor.\n\nExample\n\nHere we simulate Akesson model in the most simple version with one trophic level, one patch, and where competition is temperature dependent. The code starts by setting the simulation time frame, choosing a differential equation solver algorithm, and defining the tolerance levels for the solver. The model is then initialized with various parameters, including the landscape size, carrying capacity, and temperature dependency of competition. The temperature over a period of 6500 years is plotted using matplotlib. The model is then simulated before and after climate change, with the population density and population mean trait (optimal temperature) plotted for each time step.\n\nusing EcoEvoModelZoo\nusing PythonCall\nusing OrdinaryDiffEq\nusing ParametricModels\nplt = pyimport(\"matplotlib.pyplot\")\n\ntstart = -4000 # starting time (relative to start of climate change at t = 0)\ntend = 2500 # time at which integration ends\nalg = Tsit5()\nabstol = 1e-6\nreltol = 1e-6\n# integrate prob with Julia\ntspan = (tstart, 0)\ntsteps = tspan[1]:200:tspan[2]\nL = 10\nSR = 50\ntemp = Temperature()\nland = Landscape(L)\n\nmodel = init_akesson_model(;mp = ModelParams(;tspan, alg, reltol, abstol, saveat = tsteps),\n                            land = Landscape(L),\n                            temp,\n                            SR = SR,\n                            width_growth = WidthGrowth{:TraitDep}(), \n                            competition = Competition{:TraitDep}(), \n                            trophic= Trophic{false}(), \n                            )\n\n# Plotting temperature over 6500 years, from -4000 to 2500\nfig, ax = plt.subplots(1)\nts = -100:1:400\np = get_p(model)\ntemp_ts = [temp.(land.x, t)[1] for t in ts]\nax.plot(ts, temp_ts)\ndisplay(fig)\n\n#################\n### BEFORE Climate Change ###\n#################\nsol = simulate(model)\node_data = Array(sol)\n\n# initial temperature\ntemp.(land.x, 100.)\n\n# plotting evolution before CC\nfig, ax = plt.subplots(1)\nl = 1 # patch index\nplotting_N_through_time(ax, ode_data, tsteps, l, model)\n# ax.set_yscale(\"log\")\ndisplay(fig)\n\n\n#################\n### After Climate Change  ###\n#################\ntspan = (0, 300)\nstep = 1\ntsteps = tspan[1]:1.:tspan[2]\nsol = simulate(model, tspan = tspan, saveat = tsteps, u0 = ode_data[:,:,end])\node_data = Array(sol)\n\n# plotting evolution after CC\nfig, axs = plt.subplots(1, 2)\nts = 1:length(tsteps)\nl = 1 # patch index\nplotting_N_through_time(axs[0], ode_data, tsteps, l, model)\naxs[0].set_ylabel(\"Population density\")\n# axs[0].set_yscale(\"log\")\nplotting_mu_through_time(axs[1], ode_data, tsteps, l, model)\naxs[1].set_ylabel(\"Population mean trait\n(Optimal temperature)\")\nfig.tight_layout()\n\n\n\n\n\n","category":"method"},{"location":"#EcoEvoModelZoo.smoothstep-Tuple{Any}","page":"Home","title":"EcoEvoModelZoo.smoothstep","text":"Apply twice continuously differentiable smoothed step function to a number x Input: x: Distance from pole, measured in units of the pole-to-equator distance Output: 0 if x < 0; 10x^3-15x^4+6*x^5 if 0 <= x <= 1; otherwise 1\n\n\n\n\n\n","category":"method"}]
}
